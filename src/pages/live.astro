---
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/Header.astro";
import CompactMatchesList from "@/components/CompactMatchesList.astro";
import Icons from "@/components/Icons.astro";
import { tennisApi } from "@/lib/api/tennisApi";

let liveMatches;
let todayMatches;
let error;

// Get date from URL parameters (default to today)
const dateParam = Astro.url.searchParams.get('date');
const today = new Date().toISOString().split('T')[0];
const targetDate = dateParam && /^\d{4}-\d{2}-\d{2}$/.test(dateParam) ? dateParam : today;

try {
  // Fetch matches. Only fetch live data when viewing today's matches.
  if (targetDate === today) {
    const [live, dateMatches] = await Promise.all([
      tennisApi.getLiveMatches(),
      tennisApi.getTodayMatches()
    ]);
    liveMatches = live;
    todayMatches = dateMatches;
  } else {
    todayMatches = await tennisApi.getMatchesByDate(targetDate);
  }

  // Debug logging
  console.log(`Live matches: ${liveMatches?.matches?.length || 0}`);
  console.log(`Today matches: ${todayMatches?.matches?.length || 0}`);
  if (liveMatches?.matches?.length > 0) {
    console.log('First live match players:', liveMatches.matches[0].players.map(p => ({ name: p.name, countryCode: p.countryCode, nationality: p.nationality })));
  }
} catch (e) {
  error = e instanceof Error ? e.message : "Failed to load matches";
  console.error("Live matches page error:", e);
}

// Combine and deduplicate matches when viewing today; otherwise use the requested date matches
let allMatches;
if (targetDate === today && liveMatches && todayMatches) {
  const matchIds = new Set(liveMatches.matches.map(m => m.id));
  const uniqueTodayMatches = todayMatches.matches.filter(m => !matchIds.has(m.id));
  allMatches = {
    matches: [...liveMatches.matches, ...uniqueTodayMatches],
    lastUpdated: new Date().toISOString()
  };
} else if (todayMatches) {
  allMatches = todayMatches;
}
---

<Layout
  title="Live Tennis Scores - Compact View"
  description="Live tennis scores in a compact, mobile-friendly format"
>
  <Header />

  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <!-- Page Header -->
    <div class="text-center mb-12">
      <div class="inline-flex items-center gap-3 mb-4">
        <Icons name="live" class="w-10 h-10 text-red-500" />
        <h1 class="text-heading-2">Live Tennis Scores</h1>
      </div>
      <p class="text-body-large max-w-4xl mx-auto">
        Follow live matches and today's schedule from ATP and WTA tournaments worldwide
      </p>
    </div>

  {error ? (
    <div class="card bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-800 p-6 text-center max-w-md mx-auto">
      <div class="mb-4">
        <Icons name="alert-triangle" class="w-10 h-10 text-red-500 mx-auto" />
      </div>
      <h3 class="text-lg font-semibold text-red-800 dark:text-red-200 mb-2">Error Loading Matches</h3>
      <p class="text-red-600 dark:text-red-300 mb-4">{error}</p>
      <button
        onclick="window.location.reload()"
        class="btn-outline"
      >
        Try Again
      </button>
    </div>
  ) : allMatches ? (
    <CompactMatchesList matches={allMatches} title="Live Tennis Scores" />
  ) : (
    <div class="text-center py-12">
      <div class="inline-block h-8 w-8 animate-spin rounded-full border-4 border-tennis-400 border-r-transparent mb-4"></div>
      <p class="text-body">Loading live matches...</p>
    </div>
  )}
  </div>

  <!-- Smart refresh script -->
  <script>
    let refreshTimer: number | undefined;
    let isVisible = true;
    let isRefreshing = false;

    // Check if we're currently on a custom date (not today)
    function isOnCustomDate() {
      const urlParams = new URLSearchParams(window.location.search);
      const dateParam = urlParams.get('date');
      const today = new Date().toISOString().split('T')[0];
      return dateParam && dateParam !== today;
    }

    // Smart refresh - only when page is visible, user isn't actively interacting, and on today's date
    function smartRefresh() {
      if (!isVisible || isRefreshing) return;

      // Don't auto-refresh if user is viewing a custom date
      if (isOnCustomDate()) {
        console.log('Skipping auto-refresh: viewing custom date');
        return;
      }

      isRefreshing = true;

      // Show loading indicator
      const indicator = document.createElement('div');
      indicator.className = 'fixed top-4 right-4 bg-yellow-500 text-white px-3 py-1 rounded-full text-sm font-medium z-50 animate-pulse';
      indicator.textContent = 'Updating scores...';
      document.body.appendChild(indicator);

      // Store current filter state
      const activeFilters = new Set<string>();
      document.querySelectorAll('.filter-btn.filter-active').forEach(btn => {
        const filterId = btn.id.replace('filter-', '');
        activeFilters.add(filterId);
      });

      // Refresh with preserved state
      const currentScroll = window.scrollY;
      fetch(window.location.href)
        .then(response => response.text())
        .then(html => {
          const parser = new DOMParser();
          const newDoc = parser.parseFromString(html, 'text/html');
          const newMain = newDoc.querySelector('main');
          const currentMain = document.querySelector('main');

          if (newMain && currentMain) {
            currentMain.innerHTML = newMain.innerHTML;
            window.scrollTo(0, currentScroll);

            // Restore filter state after a brief delay to let the new content settle
            setTimeout(() => {
              // Restore active filters
              activeFilters.forEach(filterId => {
                const btn = document.getElementById(`filter-${filterId}`);
                if (btn && !btn.classList.contains('filter-active')) {
                  btn.click(); // This will trigger the filter logic
                }
              });
            }, 100);
          }

          document.body.removeChild(indicator);
          isRefreshing = false;
        })
        .catch(() => {
          indicator.textContent = 'Update failed';
          indicator.className = indicator.className.replace('bg-yellow-500', 'bg-red-500');
          setTimeout(() => {
            if (document.body.contains(indicator)) {
              document.body.removeChild(indicator);
            }
            isRefreshing = false;
          }, 3000);
        });
    }

    // Start smart refresh timer (60 seconds instead of 30)
    function startRefreshTimer() {
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(smartRefresh, 60000);
    }

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      isVisible = !document.hidden;
      if (isVisible) {
        startRefreshTimer();
        // Only auto-refresh when returning to page if on today's date
        if (!isOnCustomDate()) {
          smartRefresh();
        }
      } else {
        clearInterval(refreshTimer);
      }
    });

    // Pause refresh during user interaction
    let interactionTimer: number | undefined;
    ['scroll', 'click', 'touchstart', 'keydown'].forEach(event => {
      document.addEventListener(event, () => {
        clearInterval(refreshTimer);
        clearTimeout(interactionTimer);

        // Resume refresh after 10 seconds of no interaction (only if on today's date)
        if (!isOnCustomDate()) {
          interactionTimer = setTimeout(startRefreshTimer, 10000);
        }
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        // Only allow manual refresh if on today's date
        if (!isOnCustomDate()) {
          smartRefresh();
        }
      }
    });

    // Start the timer only if on today's date
    if (!isOnCustomDate()) {
      startRefreshTimer();
    }
  </script>
</Layout>

<style>
  .animate-spin {
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
</style>
